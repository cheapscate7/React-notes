__d(function (global, require, module, exports, _dependencyMap) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var tslib_1 = require(_dependencyMap[0], "tslib");

    var hash_1 = require(_dependencyMap[1], "./hash");

    var Sha1 = function (_super) {
        tslib_1.__extends(Sha1, _super);

        function Sha1() {
            var _this = _super.call(this) || this;

            _this.chain_ = [];
            _this.buf_ = [];
            _this.W_ = [];
            _this.pad_ = [];
            _this.inbuf_ = 0;
            _this.total_ = 0;
            _this.blockSize = 512 / 8;
            _this.pad_[0] = 128;

            for (var i = 1; i < _this.blockSize; ++i) {
                _this.pad_[i] = 0;
            }

            _this.reset();

            return _this;
        }

        Sha1.prototype.reset = function () {
            this.chain_[0] = 0x67452301;
            this.chain_[1] = 0xefcdab89;
            this.chain_[2] = 0x98badcfe;
            this.chain_[3] = 0x10325476;
            this.chain_[4] = 0xc3d2e1f0;
            this.inbuf_ = 0;
            this.total_ = 0;
        };

        Sha1.prototype.compress_ = function (buf, opt_offset) {
            if (!opt_offset) {
                opt_offset = 0;
            }

            var W = this.W_;

            if (typeof buf === 'string') {
                for (var i = 0; i < 16; i++) {
                    W[i] = buf.charCodeAt(opt_offset) << 24 | buf.charCodeAt(opt_offset + 1) << 16 | buf.charCodeAt(opt_offset + 2) << 8 | buf.charCodeAt(opt_offset + 3);
                    opt_offset += 4;
                }
            } else {
                for (var i = 0; i < 16; i++) {
                    W[i] = buf[opt_offset] << 24 | buf[opt_offset + 1] << 16 | buf[opt_offset + 2] << 8 | buf[opt_offset + 3];
                    opt_offset += 4;
                }
            }

            for (var i = 16; i < 80; i++) {
                var t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                W[i] = (t << 1 | t >>> 31) & 0xffffffff;
            }

            var a = this.chain_[0];
            var b = this.chain_[1];
            var c = this.chain_[2];
            var d = this.chain_[3];
            var e = this.chain_[4];
            var f, k;

            for (var i = 0; i < 80; i++) {
                if (i < 40) {
                    if (i < 20) {
                        f = d ^ b & (c ^ d);
                        k = 0x5a827999;
                    } else {
                        f = b ^ c ^ d;
                        k = 0x6ed9eba1;
                    }
                } else {
                    if (i < 60) {
                        f = b & c | d & (b | c);
                        k = 0x8f1bbcdc;
                    } else {
                        f = b ^ c ^ d;
                        k = 0xca62c1d6;
                    }
                }

                var t = (a << 5 | a >>> 27) + f + e + k + W[i] & 0xffffffff;
                e = d;
                d = c;
                c = (b << 30 | b >>> 2) & 0xffffffff;
                b = a;
                a = t;
            }

            this.chain_[0] = this.chain_[0] + a & 0xffffffff;
            this.chain_[1] = this.chain_[1] + b & 0xffffffff;
            this.chain_[2] = this.chain_[2] + c & 0xffffffff;
            this.chain_[3] = this.chain_[3] + d & 0xffffffff;
            this.chain_[4] = this.chain_[4] + e & 0xffffffff;
        };

        Sha1.prototype.update = function (bytes, opt_length) {
            if (bytes == null) {
                return;
            }

            if (opt_length === undefined) {
                opt_length = bytes.length;
            }

            var lengthMinusBlock = opt_length - this.blockSize;
            var n = 0;
            var buf = this.buf_;
            var inbuf = this.inbuf_;

            while (n < opt_length) {
                if (inbuf == 0) {
                    while (n <= lengthMinusBlock) {
                        this.compress_(bytes, n);
                        n += this.blockSize;
                    }
                }

                if (typeof bytes === 'string') {
                    while (n < opt_length) {
                        buf[inbuf] = bytes.charCodeAt(n);
                        ++inbuf;
                        ++n;

                        if (inbuf == this.blockSize) {
                            this.compress_(buf);
                            inbuf = 0;
                            break;
                        }
                    }
                } else {
                    while (n < opt_length) {
                        buf[inbuf] = bytes[n];
                        ++inbuf;
                        ++n;

                        if (inbuf == this.blockSize) {
                            this.compress_(buf);
                            inbuf = 0;
                            break;
                        }
                    }
                }
            }

            this.inbuf_ = inbuf;
            this.total_ += opt_length;
        };

        Sha1.prototype.digest = function () {
            var digest = [];
            var totalBits = this.total_ * 8;

            if (this.inbuf_ < 56) {
                this.update(this.pad_, 56 - this.inbuf_);
            } else {
                this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
            }

            for (var i = this.blockSize - 1; i >= 56; i--) {
                this.buf_[i] = totalBits & 255;
                totalBits /= 256;
            }

            this.compress_(this.buf_);
            var n = 0;

            for (var i = 0; i < 5; i++) {
                for (var j = 24; j >= 0; j -= 8) {
                    digest[n] = this.chain_[i] >> j & 255;
                    ++n;
                }
            }

            return digest;
        };

        return Sha1;
    }(hash_1.Hash);

    exports.Sha1 = Sha1;
});